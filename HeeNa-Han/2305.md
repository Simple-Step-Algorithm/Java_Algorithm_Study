# 230505 금요일

## [프로그래머스] 무인도 여행

bfs 풀었다. 

먼저 split를 사용하여 maps를 이차원 배열로 만든다. 
만약 방문하지 않았거나 섬일 경우 그래프 탐색을 시도한다. 

연결된 섬을 방문하면서 합계를 계산한다. 
모든 합계를 리스트에 넣는다.

리스트의 사이즈가 0이면 { -1 } 배열을 return하고 그렇지 않으면 스트림으로 만든 뒤 정렬 후 배열로 만든 후 return한다. 

```java
import java.util.*;

class Node {
    private int x;
    private int y;
    
    public Node(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public int getX() { return x; }
    public int getY() { return y; }
}

class Solution {
    
    int[] dx = { 1, 0, -1, 0 };
    int[] dy = { 0, 1, 0, -1 };
    boolean[][] visited;
    
    public int[] solution(String[] maps) {
        List<Integer> answer = new ArrayList<>();
        int n = maps.length; // 행
        int m = maps[0].length(); // 열

        // 1. split를 사용하여 maps을 이차원 배열로 만든다.
        String[][] arr = Arrays.stream(maps)
                            .map(map -> map.split(""))
                            .toArray(String[][]::new);
        
        visited = new boolean[n][m];
        
        // 2. 방문하지 않았거나 섬이라면 bfs를 수행한다.
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && !arr[i][j].equals("X")) answer.add(bfs(n, m, i, j, arr));
            }
        }
        
        // 3. 크기가 0이면 { -1 } 배열을 return하고 아니면 스트림으로 만든 뒤 정렬하고 배열로 만든 뒤 return한다.
        return answer.size() == 0 ? new int[]{ -1 } : answer.stream().sorted().mapToInt(i -> i).toArray();
    }
    
    // 2.1. 연결된 섬의 합계를 구한 뒤 return한다.
    public int bfs(int n, int m, int i, int j, String[][] maps) {
        Queue<Node> q = new LinkedList<>();
        q.add(new Node(i, j));
        visited[i][j] = true;
        int sum = 0;
        
        while (!q.isEmpty()) {
            Node v = q.poll();
            int x = v.getX();
            int y = v.getY();
            
            sum += Integer.parseInt(maps[x][y]);
            
            for (int k = 0; k < 4; k++) {
                int nx = x + dx[k];
                int ny = y + dy[k];
                
                if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                if (visited[nx][ny] || maps[nx][ny].equals("X")) continue;
                
                q.add(new Node(nx, ny));
                visited[nx][ny] = true;
            }
        }
        
        return sum;
    }
    
}
```

## [프로그래머스] 가장 큰 정사각형 찾기

board[i][j]는 지금 j열에서 1이 몇 번 이어지고 있는지 저장하고 있다.

예를 들어

1 1 1

0 1 1

1 1 1 

이라면

1 1 1

0 2 2

1 3 3 

이렇게 된다.

answer은 지금까지 구한 가장 큰 정사각형이다. 따라서 다음으로 큰 정사각형을 구할수 있을지 확인해야 한다. 다음으로 큰 정사각형이 3이라면 i번째 행에서 3이상의 수가 세 번 연속해야 한다.

```java
class Solution
{
    public int solution(int[][] board)
    {
        int answer = 0;

        int n = board.length;
        int m = board[0].length;
        
        for (int i = 0; i < n; i++) {
            int count = 0; 
            // 1. board[i][j]는 j열에서 1이 몇 번 이어지고 있는지 저장된다.
            for (int j = 0; j < m; j++) {
                if (i > 0 && board[i][j] == 1) board[i][j] += board[i - 1][j];
            }
            // 2. answer에는 다음으로 큰 정사각형이 저장되어 있다. 
            //    n 크기의 정사각형이 되기 위해선 n 이상의 수가 n번 연속해야 한다.
            for (int j = 0; j < m; j++) {
                if (board[i][j] >= answer + 1) count++;
                else count = 0;
                if (count == answer + 1) {
                    answer++;
                    break;
                }
            }
        }

        return answer * answer;
    }
}
```

# 230508 월요일

## [프로그래머스] 점 찍기

√ x^2 + y^2 <= d이다. 

따라서 이 공식을 이용하여 x가 주어질 때 y의 최댓값을 구한다.

x를 0부터 k만큼 증가시키면서 y를 구한다. 이때 x는 d보다 작거나 같다.
   
√ d^2 - x^2가 y의 최댓값이므로 y / k + 1 (0 포함)이 될 수 있는 y의 개수이다. 
```java
class Solution {

    public long solution(int k, int d) {
        long answer = 0;
        for (long i = 0; i * k <= d; i++) {
            long x = i * k;
            long y = (long) Math.sqrt((long) d * d - x * x);
            answer += y / k + 1; // 0 포함
        }
        return answer;
    }

}
```