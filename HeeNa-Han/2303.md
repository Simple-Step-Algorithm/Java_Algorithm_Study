# 230320 월요일

## [프로그래머스] 로또의 최고 순위와 최저 순위
최고 순위는 알아볼 수 없는 숫자 0을 모두 맞췄을 경우이다.
최저 순위는 알아볼 수 없는 숫자 0을 모두 맞추지 못했을 경우이다.
```java
class Solution {
    
    // 순위는 미리 정의
    int[] ranking = { 6, 6, 5, 4, 3, 2, 1 };
    
    public int[] solution(int[] lottos, int[] win_nums) {
        int[] answer = new int[2];
        // lottos에서 0의 개수
        int zeroCount = 0; 
        // lottos와 win_nums가 일치하는 수의 개수
        int matchCount = 0;
        // lottos에서 0의 개수를 센다.
        for (int i = 0; i < 6; i++) {
            if (lottos[i] == 0) zeroCount++; 
        }
        // win_nums의 수가 lottos에 존재하는지 확인
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 6; j++) {
                if (win_nums[i] == lottos[j]) {
                    matchCount++;
                    break;
                }
            }
        }
        answer[0] = ranking[zeroCount + matchCount]; // 최고
        answer[1] = ranking[matchCount]; // 최저
        return answer;
    }

}
```

## [프로그래머스] 숫자 짝꿍
배열을 사용해 문자열 X와 Y에서 숫자가 몇 번 나타나는지 계산한다. xNum[9] = 1은 문자열 X에 9가 1번 나타났다는 뜻이다. 

다음으로 공통으로 나타나는 정수를 이용해 가장 큰 숫자를 만들어야 한다. 따라서 가장 큰 숫자가 앞으로 와야 하므로 9부터 차례로 문자열(결과)에 추가한다.

String에 문자열을 더할 때마다 새로운 객체를 생성해 할당하므로 시간이 오래 걸린다. 따라서 StringBuilder를 사용했다. 
```java
class Solution {
    
    public String solution(String X, String Y) {
        StringBuilder sb = new 
        StringBuilder();
        // X와 Y를 char 배열로 만들어 숫자가 몇 번 나타는지 계산
        int[] xNum = new int[10];
        for (char c : X.toCharArray()) xNum[c - '0']++;
        int[] yNum = new int[10];
        for (char c : Y.toCharArray()) yNum[c - '0']++;
        // xNum[9] = 1, yNum[9] = 2이면 더 작은 수만큼 결과에 9를 더한다.
        for (int i = 9; i >= 0; i--) {
            int min = Integer.min(xNum[i], yNum[i]);
            // 만약 빈 문자고 공통으로 나타나는 0이 하나라도 존재한다면 0을 한 번 더한다.
            if (i == 0 && sb.length() == 0 && min > 0) {
                sb.append(0);
            } else {
                for (int j = 0; j < min; j++) sb.append(i);
            }
        }
        // 빈 문자이면 -1를 return한다.
        return sb.length() == 0 ? "-1" : sb.toString();
    }
}
```

## [프로그래머스] 위장
해시와 조합 문제이다. 먼저 특정 의상의 종류는 몇 가지인를 알아야 한다. 이때 getOrDefault 메서드를 사용했다. 첫 번째 인수로 키를 전달한다. 키에 해당하는 값이 없다면 두 번째 인수로 받은 기본값을 반환한다.

만약 상의에 해당하는 옷이 A, B가 있다면 (상의를 안 입음), (A 상의를 입음), (B 상의를 입음) 세 가지 경우가 존재한다. 그리고 곱의 법칙을 이용하여 경우의 수를 계산한다.

참고로 옷을 하나도 입지 않은 경우가 포함되므로 -1한다.
```java
import java.util.Map;
import java.util.HashMap;

class Solution {
    public int solution(String[][] clothes) {
        int answer = 1;
        Map<String, Integer> map = new HashMap<>();
        // 특정 의상 종류의 가지수를 계산한다.
        for (String[] cloth : clothes) {
            map.put(cloth[1], map.getOrDefault(cloth[1], 0) + 1);
        }
        // Map의 keySet을 가져와 forEach를 하면서 경우의 수 계산.
        for (String key : map.keySet()) {
            int num = map.get(key);
            answer *= (num + 1);
        }
        return answer - 1;
    }
}
```

# 230321 화요일

## [프로그래머스] 기사단원의 무기
1부터 number까지 각 수의 약수의 개수를 구해야 한다. 따라서 1부터 number까지 반복문을 실행하면서 약수의 개수를 구한다. 

이때 시간복잡도를 줄이기 위해 1부터 제곱근까지만 반복하면서 약수를 찾는다. 그리고 문제 조건에 따라 약수의 개수가 limit를 초과하면 power를 더한다.

```java
class Solution {
    public int solution(int number, int limit, int power) {
        int answer = 0;
        // 각 수의 약수의 개수를 저장한다.
        int[] num = new int[number + 1];
        for (int i = 1; i <= number; i++) {
            // i의 약수의 개수를 찾는 반복문
            for (int j = 1; j <= Math.sqrt(i); j++) {
                if (i % j == 0) {
                    num[i]++;
                    if (i / j != j) num[i]++;
                }
            }
            // 약수의 개수가 limit를 초과하면 power를 더함
            answer += num[i] > limit ? power : num[i];
        }
        return answer;
    }
}
```

## [프로그래머스] 체육복

먼저 1부터 N까지의 학생은 체육복을 1개 가지고 있도록 한다. 그리고 lost와 reserve 배열을 forEach로 반복하며 도난맞은 학생은 체육복의 개수를 줄이고 여분을 가져온 학생은 체육복의 개수를 늘린다.

이제 1부터 N까지 반복하며 체육복이 없는 사람일 경우 양쪽 중 한 곳에서 빌린다. 이때 체육복이 2개인 사람에게만 빌릴 수 있다.

```java
import java.util.Arrays;

class Solution {
    
    public int solution(int n, int[] lost, int[] reserve) {
        int answer = 0;
        // 스트림을 사용해 1부터 N의 학생은 체육복을 1개 가지도록 함 
        int[] have = Arrays.stream(new int[n + 2]).map(num -> 1).toArray();
        // 도난맞은 학생은 개수를 줄이고 여분이 있는 학생은 개수를 올림
        for (int lo : lost) have[lo]--;
        for (int re : reserve) have[re]++;
        for (int i = 1; i <= n; i++) {
            if (have[i] == 0) { // 체육복이 없는 학생일 경우 양쪽 중 한 사람에게 빌린다.
                if (have[i - 1] > 1) {
                    have[i - 1]--; 
                    have[i]++;
                } else if (have[i + 1] > 1) {
                    have[i + 1]--; 
                    have[i]++;
                }
            }
            // 체육복을 가지고 있을 때 +1한다. 
            if (have[i] > 0) answer++;
        }
        return answer;
    }

}
```

## [프로그래머스] 덧칠하기

section은 오름차순으로 정렬되어 있다. 따라서 처음 색칠하는 부분은 section[0]이다. 다시 칠해야 하는 수들 중 가장 큰 수를 칠하는 것이 종료 조건이다.

한 번 칠할 때 m만큼 칠한다. 따라서 다음 칠할 구역은 section에서 start + m(이번에 칠한 구역)보다 큰 것 중 가장 작은 수이다.

```java
class Solution {

    public int solution(int n, int m, int[] section) {
        int answer = 0;
        int next = 0;
        int start = section[next]; // section은 오름차순
        // section의 가장 마지막 인덱스를 칠했을 때 종료
        while (section[section.length - 1] >= start + m) {
            // 다음 칠할 구역은 section에서 이번에 칠했던 구역보다 큰 수 중 가장 작은 수를 찾는다.
            while (next < section.length - 1 && start + m > section[next]) next++;
            start = section[next];
            answer++;
        }
        return answer + 1;
    }

}
```

## [프로그래머스] 카드 뭉치

투 포인터를 사용해 풀었다. c1과 c2는 cards1과 cards2의 인덱스를 가리킨다. 이제 goal 배열을 forEach로 반복하면서 cards1 혹은 cards2에 있는 문자열인지 확인한다. 두 곳 모두 일치하지 않다면 바로 "No"를 반환한다. 

```java
class Solution {

    public String solution(String[] cards1, String[] cards2, String[] goal) {
        int c1 = 0; int c2 = 0;
        for (String g : goal) {
            if (c1 < cards1.length && g.equals(cards1[c1])) c1++;
            else if (c2 < cards2.length && g.equals(cards2[c2])) c2++;
            else return "No";
        }
        return "Yes";
    }

}
```