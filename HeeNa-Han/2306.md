# 230602 금요일

## [프로그래머스] 교점에 별찍기

마지막에 별 그리는 부분에서 헤맸던 문제이다. 
처음엔 교점들을 모두 정렬을 한 다음 한 줄 씩 그리려고 했지만 스터디원 분의 말씀대로 미리 그려놓은 뒤 교점을 찍는 방법으로 바꾸었더니 쉽게 풀렸다.

이중 반복문으로 모든 직선의 교점을 구한다. 이때 두 직선의 교점이 유일하게 존재하고 x, y 두 점이 정수일 때 list에 넣는다. 교점 x, y의 최댓값과 최솟값도 함께 계산한다.

사각형의 세로 길이는 y의 최댓값 - y의 최솟값 + 1이다. 사각형의 가로 길이는 x의 최댓값 - x의 최솟값 + 1이다. 

만들어진 사각형에서 교점에 별을 찍는다. 교점의 위치는 상대적이다. m의 x값이 최솟값에 가까울 수록 인덱스 0에 가깝다. m의 y값이 최댓값에 가까울 수록 인덱스 0에 가깝다. 따라서 y의 최댓값 - m의 y가 행 인덱스이다. x의 최솟값 - m의 x 두 뺄셈의 절댓값이 열 인덱스이다.

마지막으로 문자열 배열로 만든 뒤 return한다.

```java
import java.util.*;
import java.util.stream.*;

class Meet {
    private int x; private int y;
    
    public Meet(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public int getX() { return x; }
    public int getY() { return y; }
}

class Solution {
    public String[] solution(int[][] line) {
        List<Meet> list = new ArrayList<>();
        // 최대 최소 X, 최대 최소 Y; 
        int maxX = Integer.MIN_VALUE; int minX = Integer.MAX_VALUE;
        int maxY = Integer.MIN_VALUE; int minY = Integer.MAX_VALUE;
        
        // 1. 모든 직선의 교점을 구한다.
        for (int i = 0; i < line.length; i++) {
            for (int j = i + 1; j < line.length; j++) {
                // 분모
                long deno = (long) line[i][0] * line[j][1] - (long) line[i][1] * line[j][0];
                // X 교점의 분자
                long numeX = (long) line[i][1] * line[j][2] - (long) line[i][2] * line[j][1];
                // Y 교점의 분자
                long numeY = (long) line[i][2] * line[j][0] - (long) line[i][0] * line[j][2];
                
                if (deno != 0) { // 분모가 0이면 두 직선은 평행 또는 일치
                    // 나누었을 때 둘 다 정수이다.
                    if (numeX % deno == 0 && numeY % deno == 0) {
                        list.add(new Meet((int) (numeX / deno), (int) (numeY / deno))); 
                        // 교점 x와 y의 최댓값과 최솟값을 구한다.
                        maxX = Math.max(maxX, (int) (numeX / deno));
                        minX = Math.min(minX, (int) (numeX / deno));
                        maxY = Math.max(maxY, (int) (numeY / deno));
                        minY = Math.min(minY, (int) (numeY / deno));
                    } 
                }
            }
        }
        
        /**
         * 사각형의 세로 길이 : y의 최댓값 - y의 최솟값 + 1
         * 사각형의 가로 길이 : x의 최댓값 - x 의 최솟값 + 1
         */
        char[][] str = new char[maxY - minY + 1][maxX - minX + 1];
        for (int i = 0; i < maxY - minY + 1; i++) {
            for (int j = 0; j < maxX - minX + 1; j++) str[i][j] = '.';
        }
        // 2. 사각형에서 교점을 찍는다. 
        for (Meet m : list) {
            int x = m.getX(); int y = m.getY();
            str[maxY - y][Math.abs(minX - x)] = '*';
        }
        
        String[] answer = new String[maxY - minY + 1];
        int idx = 0;
        for (char[] c : str) answer[idx++] = String.valueOf(c);
        
        return answer;
    }
}
```